<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Audio Processor</title>
    <style>
        :root {
            --bg-primary: #2d2418;
            --bg-secondary: #3d3425;
            --bg-tertiary: #4d4435;
            --text-primary: #e8dcc8;
            --text-secondary: #c4b8a4;
            --accent: #c4956a;
            --accent-hover: #d4a57a;
            --border: #5d5445;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 10px 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.2rem;
            margin-bottom: 5px;
            color: var(--accent);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 15px;
            font-style: italic;
        }

        .panel {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 12px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
        }

        /* Upload Section */
        .upload-area {
            border: 3px dashed var(--border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-tertiary);
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--accent);
            background: rgba(196, 149, 106, 0.1);
        }

        .upload-area input {
            display: none;
        }

        .upload-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .file-info {
            margin-top: 10px;
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 5px;
            display: none;
        }

        .file-info.visible {
            display: block;
        }

        /* Era Selector */
        .era-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .era-btn {
            padding: 12px 20px;
            border: 2px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-size: 1rem;
        }

        .era-btn:hover {
            border-color: var(--accent);
            background: rgba(196, 149, 106, 0.2);
        }

        .era-btn.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .era-description {
            text-align: center;
            margin-top: 10px;
            font-style: italic;
            color: var(--text-secondary);
            min-height: 20px;
        }

        /* Sliders */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .control-group {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .control-name {
            font-weight: bold;
            font-size: 0.9rem;
        }

        .control-value {
            color: var(--accent);
            font-weight: bold;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-primary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 2px solid var(--text-primary);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 2px solid var(--text-primary);
        }

        /* Playback Controls */
        .playback-section {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .playback-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            width: 100%;
            max-width: 800px;
        }

        /* Waveform & Progress */
        .waveform-container {
            width: 100%;
            height: 100px;
            background: var(--bg-primary);
            border-radius: 8px;
            margin: 10px 0;
            position: relative;
            cursor: pointer;
            overflow: hidden;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(196, 149, 106, 0.3);
            border-right: 2px solid var(--accent);
            pointer-events: none;
            width: 0%;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
            color: var(--text-secondary);
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .playback-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .btn-icon {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            font-size: 1.1rem;
        }

        .btn-play {
            width: 55px;
            height: 55px;
            font-size: 1.4rem;
        }

        .playback-label {
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--accent);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.95rem;
            transition: all 0.2s ease;
            margin: 5px;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            border-color: var(--accent);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Download Section */
        .download-section {
            text-align: center;
        }

        .format-select {
            padding: 8px 12px;
            font-size: 0.9rem;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            margin-right: 10px;
            font-family: inherit;
        }

        /* Processing Indicator */
        .processing {
            display: none;
            text-align: center;
            padding: 10px;
            color: var(--accent);
        }

        .processing.visible {
            display: block;
        }

        .spinner {
            display: inline-block;
            width: 25px;
            height: 25px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Retro Audio Processor</h1>
        <p class="subtitle">Transform your audio to sound like it's from a different era</p>

        <!-- Upload Section -->
        <div class="panel">
            <h2 class="panel-title">Upload Audio</h2>
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">&#127926;</div>
                <p>Drop an audio file here or click to browse</p>
                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">
                    Supports MP3, WAV, OGG, FLAC
                </p>
                <input type="file" id="fileInput" accept="audio/*">
            </div>
            <div class="file-info" id="fileInfo">
                <strong>Loaded:</strong> <span id="fileName"></span>
            </div>
        </div>

        <!-- Era Selector -->
        <div class="panel">
            <h2 class="panel-title">Select Era</h2>
            <div class="era-buttons" id="eraButtons">
                <button class="era-btn" data-era="1910s">1910s</button>
                <button class="era-btn" data-era="1920s">1920s</button>
                <button class="era-btn" data-era="1930s">1930s</button>
                <button class="era-btn" data-era="1940s">1940s</button>
                <button class="era-btn active" data-era="1950s">1950s</button>
                <button class="era-btn" data-era="1960s">1960s</button>
                <button class="era-btn" data-era="1970s">1970s</button>
                <button class="era-btn" data-era="1980s">1980s</button>
            </div>
            <p class="era-description" id="eraDescription">Early rock & roll, jukeboxes</p>
        </div>

        <!-- Controls -->
        <div class="panel">
            <h2 class="panel-title">Adjust Parameters</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Compression</span>
                        <span class="control-value" id="compressionValue">70%</span>
                    </div>
                    <input type="range" id="compression" min="0" max="100" value="70">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Record Hiss/Noise</span>
                        <span class="control-value" id="hissValue">35%</span>
                    </div>
                    <input type="range" id="hiss" min="0" max="100" value="35">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Filtering</span>
                        <span class="control-value" id="filteringValue">65%</span>
                    </div>
                    <input type="range" id="filtering" min="0" max="100" value="65">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Mono Blend</span>
                        <span class="control-value" id="monoValue">75%</span>
                    </div>
                    <input type="range" id="mono" min="0" max="100" value="75">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Radio Crackle</span>
                        <span class="control-value" id="crackleValue">40%</span>
                    </div>
                    <input type="range" id="crackle" min="0" max="100" value="40">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span class="control-name">Record Pop</span>
                        <span class="control-value" id="popValue">25%</span>
                    </div>
                    <input type="range" id="pop" min="0" max="100" value="25">
                </div>
            </div>
        </div>

        <!-- Playback Controls -->
        <div class="panel">
            <h2 class="panel-title">Playback</h2>
            <div class="playback-section">
                <div class="playback-box">
                    <p class="playback-label">Processed Audio</p>
                    
                    <div class="waveform-container" id="waveformContainer">
                        <canvas id="waveformCanvas"></canvas>
                        <div class="progress-overlay" id="progressOverlay"></div>
                    </div>
                    
                    <div class="time-display">
                        <span id="currentTime">00:00</span>
                        <span id="duration">00:00</span>
                    </div>
                    
                    <div class="playback-controls">
                        <button class="btn btn-secondary btn-icon" id="skipBack" title="Back 10s" disabled>&#8630;</button>
                        <button class="btn btn-primary btn-icon btn-play" id="playProcessed" title="Play/Pause" disabled>&#9658;</button>
                        <button class="btn btn-secondary btn-icon" id="skipForward" title="Forward 10s" disabled>&#8631;</button>
                    </div>
                </div>
            </div>
            <div class="processing" id="processing">
                <span class="spinner"></span>
                Processing audio...
            </div>
        </div>

        <!-- Download Section -->
        <div class="panel">
            <h2 class="panel-title">Download</h2>
            <div class="download-section">
                <select class="format-select" id="formatSelect">
                    <option value="wav">WAV (Lossless)</option>
                    <option value="mp3">MP3 (Compressed)</option>
                </select>
                <button class="btn btn-primary" id="downloadBtn" disabled>Download Processed Audio</button>
            </div>
        </div>

        <p class="footer">Era Radio Filter - Transform your audio through time</p>
    </div>

    <script>
        // Era presets configuration
        const ERA_PRESETS = {
            '1910s': {
                compression: 100,
                hiss: 90,
                filtering: 100,
                mono: 100,
                crackle: 95,
                pop: 80,
                lowFreq: 500,
                highFreq: 2500,
                description: 'Spark gap era, extremely primitive, barely intelligible'
            },
            '1920s': {
                compression: 95,
                hiss: 80,
                filtering: 95,
                mono: 100,
                crackle: 85,
                pop: 70,
                lowFreq: 400,
                highFreq: 2800,
                description: 'Crystal radio era, AM broadcast beginnings'
            },
            '1930s': {
                compression: 90,
                hiss: 70,
                filtering: 90,
                mono: 100,
                crackle: 75,
                pop: 60,
                lowFreq: 300,
                highFreq: 3000,
                description: 'AM radio, lo-fi, scratchy'
            },
            '1940s': {
                compression: 80,
                hiss: 50,
                filtering: 85,
                mono: 100,
                crackle: 60,
                pop: 50,
                lowFreq: 250,
                highFreq: 3500,
                description: 'War-era radio, slightly clearer'
            },
            '1950s': {
                compression: 70,
                hiss: 35,
                filtering: 65,
                mono: 75,
                crackle: 40,
                pop: 25,
                lowFreq: 200,
                highFreq: 5000,
                description: 'Early rock & roll, jukeboxes'
            },
            '1960s': {
                compression: 50,
                hiss: 20,
                filtering: 45,
                mono: 50,
                crackle: 25,
                pop: 15,
                lowFreq: 150,
                highFreq: 8000,
                description: 'FM emergence, cleaner but warm'
            },
            '1970s': {
                compression: 30,
                hiss: 10,
                filtering: 25,
                mono: 0,
                crackle: 10,
                pop: 5,
                lowFreq: 100,
                highFreq: 10000,
                description: 'Near hi-fi, slight warmth/saturation'
            },
            '1980s': {
                compression: 20,
                hiss: 5,
                filtering: 15,
                mono: 0,
                crackle: 5,
                pop: 2,
                lowFreq: 80,
                highFreq: 12000,
                description: 'FM dominance, clean, modern warmth'
            }
        };

        // State
        let audioContext = null;
        let originalBuffer = null;
        let processedBuffer = null;
        let currentSource = null;
        let isPlaying = false;
        let currentPlayingType = null; // 'original' or 'processed'
        let currentEra = '1950s';
        
        // New Playback State
        let playStartTime = 0;
        let pausedAt = 0;
        let playbackInterval = null;

        // DOM Elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const eraButtons = document.querySelectorAll('.era-btn');
        const eraDescription = document.getElementById('eraDescription');
        const compressionSlider = document.getElementById('compression');
        const hissSlider = document.getElementById('hiss');
        const filteringSlider = document.getElementById('filtering');
        const monoSlider = document.getElementById('mono');
        const crackleSlider = document.getElementById('crackle');
        const popSlider = document.getElementById('pop');
        const compressionValue = document.getElementById('compressionValue');
        const hissValue = document.getElementById('hissValue');
        const filteringValue = document.getElementById('filteringValue');
        const monoValue = document.getElementById('monoValue');
        const crackleValue = document.getElementById('crackleValue');
        const popValue = document.getElementById('popValue');
        const playProcessedBtn = document.getElementById('playProcessed');
        const skipBackBtn = document.getElementById('skipBack');
        const skipForwardBtn = document.getElementById('skipForward');
        const downloadBtn = document.getElementById('downloadBtn');
        const formatSelect = document.getElementById('formatSelect');
        const processing = document.getElementById('processing');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const progressOverlay = document.getElementById('progressOverlay');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const waveformContainer = document.getElementById('waveformContainer');

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        // File upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                handleFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            initAudioContext();
            fileName.textContent = file.name;
            fileInfo.classList.add('visible');
            
            // Reset playback state for new file
            stopPlayback();
            pausedAt = 0;
            updateProgress();

            const arrayBuffer = await file.arrayBuffer();
            originalBuffer = await audioContext.decodeAudioData(arrayBuffer);

            await processAudio();
        }

        // Era selection
        eraButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                eraButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentEra = btn.dataset.era;
                applyPreset(currentEra);
            });
        });

        function applyPreset(era) {
            const preset = ERA_PRESETS[era];
            compressionSlider.value = preset.compression;
            hissSlider.value = preset.hiss;
            filteringSlider.value = preset.filtering;
            monoSlider.value = preset.mono;
            crackleSlider.value = preset.crackle;
            popSlider.value = preset.pop;
            updateSliderDisplays();
            eraDescription.textContent = preset.description;

            if (originalBuffer) {
                processAudio();
            }
        }

        function updateSliderDisplays() {
            compressionValue.textContent = compressionSlider.value + '%';
            hissValue.textContent = hissSlider.value + '%';
            filteringValue.textContent = filteringSlider.value + '%';
            monoValue.textContent = monoSlider.value + '%';
            crackleValue.textContent = crackleSlider.value + '%';
            popValue.textContent = popSlider.value + '%';
        }

        // Slider event listeners
        [compressionSlider, hissSlider, filteringSlider, monoSlider, crackleSlider, popSlider].forEach(slider => {
            slider.addEventListener('input', () => {
                updateSliderDisplays();
            });
            slider.addEventListener('change', () => {
                if (originalBuffer) {
                    processAudio();
                }
            });
        });

        // Audio processing
        async function processAudio() {
            if (!originalBuffer) return;

            const wasPlayingProcessed = (currentPlayingType === 'processed');

            processing.classList.add('visible');
            playProcessedBtn.disabled = true;
            downloadBtn.disabled = true;

            // Process in next frame to allow UI update
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const preset = ERA_PRESETS[currentEra];
                const filterAmount = filteringSlider.value / 100;
                const monoAmount = monoSlider.value / 100;
                const hissAmount = hissSlider.value / 100;
                const compAmount = compressionSlider.value / 100;
                const crackleAmount = crackleSlider.value / 100;
                const popAmount = popSlider.value / 100;

                // Calculate filter frequencies based on preset and slider
                const fullLow = 20;
                const fullHigh = 20000;
                const lowFreq = fullLow + (preset.lowFreq - fullLow) * filterAmount;
                const highFreq = fullHigh - (fullHigh - preset.highFreq) * filterAmount;

                // Create offline context for processing
                const offlineCtx = new OfflineAudioContext(
                    originalBuffer.numberOfChannels,
                    originalBuffer.length,
                    originalBuffer.sampleRate
                );

                // Source
                const source = offlineCtx.createBufferSource();
                source.buffer = originalBuffer;

                // Mono conversion
                let currentNode = source;
                if (monoAmount > 0 && originalBuffer.numberOfChannels > 1) {
                    // Create mono mix using channel merger/splitter
                    const splitter = offlineCtx.createChannelSplitter(2);
                    const merger = offlineCtx.createChannelMerger(2);
                    const leftGain = offlineCtx.createGain();
                    const rightGain = offlineCtx.createGain();
                    const monoGain = offlineCtx.createGain();

                    // Mix stereo based on mono amount
                    const stereoMix = 1 - monoAmount;

                    currentNode.connect(splitter);
                    splitter.connect(leftGain, 0);
                    splitter.connect(rightGain, 1);
                    splitter.connect(monoGain, 0);
                    splitter.connect(monoGain, 1);

                    monoGain.gain.value = 0.5 * monoAmount;
                    leftGain.gain.value = stereoMix;
                    rightGain.gain.value = stereoMix;

                    leftGain.connect(merger, 0, 0);
                    rightGain.connect(merger, 0, 1);
                    monoGain.connect(merger, 0, 0);
                    monoGain.connect(merger, 0, 1);

                    currentNode = merger;
                }

                // High-pass filter
                const highPass = offlineCtx.createBiquadFilter();
                highPass.type = 'highpass';
                highPass.frequency.value = lowFreq;
                highPass.Q.value = 0.7;
                currentNode.connect(highPass);
                currentNode = highPass;

                // Low-pass filter
                const lowPass = offlineCtx.createBiquadFilter();
                lowPass.type = 'lowpass';
                lowPass.frequency.value = highFreq;
                lowPass.Q.value = 0.7;
                currentNode.connect(lowPass);
                currentNode = lowPass;

                // Compressor
                const compressor = offlineCtx.createDynamicsCompressor();
                compressor.threshold.value = -50 + (1 - compAmount) * 40; // -50 to -10 dB
                compressor.knee.value = 40 * compAmount;
                compressor.ratio.value = 1 + compAmount * 19; // 1 to 20
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;
                currentNode.connect(compressor);
                currentNode = compressor;

                // Add some saturation/warmth for older eras via waveshaper
                if (compAmount > 0.3) {
                    const waveshaper = offlineCtx.createWaveShaper();
                    waveshaper.curve = makeDistortionCurve(compAmount * 20);
                    waveshaper.oversample = '2x';
                    currentNode.connect(waveshaper);
                    currentNode = waveshaper;
                }

                // Main gain
                const mainGain = offlineCtx.createGain();
                mainGain.gain.value = 0.8;
                currentNode.connect(mainGain);
                currentNode = mainGain;

                // Mix with noise
                const mixGain = offlineCtx.createGain();
                currentNode.connect(mixGain);

                if (hissAmount > 0) {
                    const noiseBuffer = createNoiseBuffer(offlineCtx, originalBuffer.length, hissAmount, preset);
                    const noiseSource = offlineCtx.createBufferSource();
                    noiseSource.buffer = noiseBuffer;

                    const noiseGain = offlineCtx.createGain();
                    noiseGain.gain.value = hissAmount * 0.15;

                    // Filter noise for more realistic sound
                    const noiseFilter = offlineCtx.createBiquadFilter();
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.value = (lowFreq + highFreq) / 2;
                    noiseFilter.Q.value = 0.5;

                    noiseSource.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(mixGain);
                    noiseSource.start();
                }

                // Add crackle and pop effects
                if (crackleAmount > 0 || popAmount > 0) {
                    const cracklePopBuffer = createCracklePopBuffer(offlineCtx, originalBuffer.length, crackleAmount, popAmount, preset);
                    const cracklePopSource = offlineCtx.createBufferSource();
                    cracklePopSource.buffer = cracklePopBuffer;

                    const cracklePopGain = offlineCtx.createGain();
                    cracklePopGain.gain.value = 0.3; // Overall level control

                    cracklePopSource.connect(cracklePopGain);
                    cracklePopGain.connect(mixGain);
                    cracklePopSource.start();
                }

                mixGain.connect(offlineCtx.destination);
                source.start();

                processedBuffer = await offlineCtx.startRendering();

                playProcessedBtn.disabled = false;
                skipBackBtn.disabled = false;
                skipForwardBtn.disabled = false;
                downloadBtn.disabled = false;
                
                drawWaveform(processedBuffer);
                durationDisplay.textContent = formatTime(processedBuffer.duration);

                if (wasPlayingProcessed) {
                    stopPlayback();
                    togglePlayback('processed', pausedAt); // Resume from where we were
                }
            } catch (error) {
                console.error('Error processing audio:', error);
            } finally {
                processing.classList.remove('visible');
            }
        }

        function drawWaveform(buffer) {
            const width = waveformCanvas.width = waveformCanvas.offsetWidth || 800;
            const height = waveformCanvas.height = waveformCanvas.offsetHeight || 120;
            const ctx = waveformCanvas.getContext('2d');
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / width);
            const amp = height / 2;

            if (step === 0) return;

            ctx.fillStyle = '#2d2418';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = '#c4956a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, amp);

            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;
                for (let j = 0; j < step; j++) {
                    const idx = (i * step) + j;
                    if (idx >= data.length) break;
                    const datum = data[idx];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }
                ctx.lineTo(i, (1 + min) * amp);
                ctx.lineTo(i, (1 + max) * amp);
            }

            ctx.stroke();
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;

            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
            }
            return curve;
        }

        function createNoiseBuffer(ctx, length, amount, preset) {
            const buffer = ctx.createBuffer(2, length, ctx.sampleRate);

            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const data = buffer.getChannelData(channel);
                let lastValue = 0;

                for (let i = 0; i < length; i++) {
                    // Mix white and pink noise
                    const white = Math.random() * 2 - 1;

                    // Simple pink noise approximation
                    lastValue = lastValue * 0.99 + white * 0.01;
                    const pink = lastValue * 10;

                    // Mix noise types (hiss only, crackle is separate now)
                    data[i] = (white * 0.3 + pink * 0.7) * amount;
                }
            }
            return buffer;
        }

        function createCracklePopBuffer(ctx, length, crackleAmount, popAmount, preset) {
            const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
            const era = parseInt(currentEra);
            const sampleRate = ctx.sampleRate;

            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const data = buffer.getChannelData(channel);

                // Apply crackle events
                if (crackleAmount > 0) {
                    const baseCrackleChance = era < 1940 ? 0.001 : era < 1960 ? 0.0005 : 0.0002;
                    const crackleChance = baseCrackleChance * crackleAmount;
                    const numCrackles = Math.floor(length * crackleChance);

                    for (let c = 0; c < numCrackles; c++) {
                        const start = Math.floor(Math.random() * length);
                        const burstLength = Math.floor(sampleRate * (0.001 + Math.random() * 0.01));
                        const end = Math.min(length, start + burstLength);

                        for (let i = start; i < end; i++) {
                            const t = (i - start) / (end - start);
                            const amplitude = (1 - t) * (1 - t) * Math.exp(-t * 5);
                            const noise = (Math.random() * 2 - 1) * 0.8;
                            data[i] += noise * amplitude * crackleAmount;
                        }
                    }
                }

                // Apply pop events
                if (popAmount > 0) {
                    const basePopChance = era < 1950 ? 0.0003 : era < 1970 ? 0.0001 : 0.00005;
                    const popChance = basePopChance * popAmount;
                    const numPops = Math.floor(length * popChance);

                    for (let p = 0; p < numPops; p++) {
                        const start = Math.floor(Math.random() * length);
                        const popLength = Math.floor(sampleRate * (0.005 + Math.random() * 0.02));
                        const end = Math.min(length, start + popLength);

                        for (let i = start; i < end; i++) {
                            const t = (i - start) / (end - start);
                            const amplitude = Math.exp(-t * 3) * (1 - t * 0.5);
                            const lowFreqNoise = (Math.random() * 2 - 1) * 0.6;
                            data[i] += lowFreqNoise * amplitude * popAmount;
                        }
                    }
                }
            }
            return buffer;
        }

        // Playback controls
        playProcessedBtn.addEventListener('click', () => togglePlayback('processed'));
        
        skipBackBtn.addEventListener('click', () => {
            if (!processedBuffer) return;
            const newPos = Math.max(0, getCurrentTime() - 10);
            seekTo(newPos);
        });

        skipForwardBtn.addEventListener('click', () => {
            if (!processedBuffer) return;
            const newPos = Math.min(processedBuffer.duration, getCurrentTime() + 10);
            seekTo(newPos);
        });

        waveformContainer.addEventListener('click', (e) => {
            if (!processedBuffer) return;
            const rect = waveformContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            const newPos = percent * processedBuffer.duration;
            seekTo(newPos);
        });

        function getCurrentTime() {
            if (currentPlayingType && currentSource && isPlaying) {
                return pausedAt + (audioContext.currentTime - playStartTime);
            }
            return pausedAt;
        }

        function seekTo(seconds) {
            const wasPlaying = isPlaying;
            stopPlayback();
            pausedAt = seconds;
            updateProgress();
            if (wasPlaying) {
                togglePlayback('processed', seconds);
            }
        }

        function updateProgress() {
            const time = getCurrentTime();
            const duration = processedBuffer ? processedBuffer.duration : 0;
            const percent = duration > 0 ? (time / duration) * 100 : 0;
            
            progressOverlay.style.width = `${percent}%`;
            currentTimeDisplay.textContent = formatTime(time);

            if (time >= duration && isPlaying) {
                stopPlayback();
            }
        }

        function stopPlayback() {
            if (currentSource) {
                try {
                    currentSource.stop();
                } catch (e) {}
                currentSource = null;
            }
            
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }

            if (isPlaying) {
                pausedAt += (audioContext.currentTime - playStartTime);
            }
            
            isPlaying = false;
            currentPlayingType = null;
            playProcessedBtn.innerHTML = '&#9658;'; // Play icon
        }

        function togglePlayback(type, startOffset = pausedAt) {
            initAudioContext();

            if (isPlaying && currentPlayingType === type) {
                stopPlayback();
                return;
            }

            stopPlayback();

            const buffer = processedBuffer;
            if (!buffer) return;

            if (startOffset >= buffer.duration) {
                startOffset = 0;
            }

            currentSource = audioContext.createBufferSource();
            currentSource.buffer = buffer;
            currentSource.connect(audioContext.destination);
            
            playStartTime = audioContext.currentTime;
            pausedAt = startOffset;
            
            currentSource.start(0, startOffset);
            isPlaying = true;
            currentPlayingType = type;

            playProcessedBtn.innerHTML = '&#10074;&#10074;'; // Pause icon

            playbackInterval = setInterval(updateProgress, 100);

            currentSource.onended = () => {
                if (isPlaying) {
                    stopPlayback();
                    pausedAt = 0;
                    updateProgress();
                }
            };
        }

        // Download
        downloadBtn.addEventListener('click', async () => {
            if (!processedBuffer) return;

            const format = formatSelect.value;

            if (format === 'wav') {
                downloadWav();
            } else {
                // MP3 encoding using lamejs
                await downloadMp3();
            }
        });

        function downloadWav() {
            const wav = audioBufferToWav(processedBuffer);
            const blob = new Blob([wav], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `processed_${currentEra}_audio.wav`;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function downloadMp3() {
            // Show processing indicator
            processing.classList.add('visible');
            processing.textContent = 'Encoding MP3...';
            downloadBtn.disabled = true;

            try {
                // Check if lamejs is available
                if (typeof lamejs === 'undefined') {
                    // Load lamejs from CDN if not available
                    processing.textContent = 'Loading MP3 encoder...';
                    await loadLamejs();
                }

                processing.textContent = 'Encoding MP3...';

                // Ensure we have at least 1 channel
                const numChannels = Math.max(1, processedBuffer.numberOfChannels);
                // Use standard MP3 sample rate (clamp to supported rates)
                const sampleRate = Math.min(48000, Math.max(8000, processedBuffer.sampleRate));

                const mp3encoder = new lamejs.Mp3Encoder(
                    numChannels,
                    sampleRate,
                    128 // bitrate
                );

                const samples = [];
                for (let i = 0; i < processedBuffer.numberOfChannels; i++) {
                    samples.push(processedBuffer.getChannelData(i));
                }

                const sampleBlockSize = 1152;
                const mp3Data = [];

                // Encode in chunks for better performance
                const totalSamples = processedBuffer.length;
                for (let i = 0; i < totalSamples; i += sampleBlockSize) {
                    const left = [];
                    const right = [];
                    const chunkSize = Math.min(sampleBlockSize, totalSamples - i);

                    for (let j = 0; j < chunkSize; j++) {
                        const sampleIdx = i + j;
                        // Convert float to 16-bit PCM
                        const leftSample = Math.max(-1, Math.min(1, samples[0][sampleIdx]));
                        const leftInt = leftSample < 0 ? leftSample * 0x8000 : leftSample * 0x7FFF;
                        left.push(leftInt);

                        if (numChannels === 2 && processedBuffer.numberOfChannels >= 2) {
                            const rightSample = Math.max(-1, Math.min(1, samples[1][sampleIdx]));
                            const rightInt = rightSample < 0 ? rightSample * 0x8000 : rightSample * 0x7FFF;
                            right.push(rightInt);
                        } else {
                            // Mono: duplicate left channel
                            right.push(leftInt);
                        }
                    }

                    const mp3buf = mp3encoder.encodeBuffer(left, right);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                    }
                }

                // Flush remaining data
                const mp3buf = mp3encoder.flush();
                if (mp3buf.length > 0) {
                    mp3Data.push(mp3buf);
                }

                // Create blob and download
                const blob = new Blob(mp3Data, { type: 'audio/mp3' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `processed_${currentEra}_audio.mp3`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('MP3 encoding error:', error);
                alert('MP3 encoding failed. Downloading as WAV instead.');
                downloadWav();
            } finally {
                processing.classList.remove('visible');
                processing.textContent = 'Processing audio...';
                downloadBtn.disabled = false;
            }
        }

        function loadLamejs() {
            return new Promise((resolve, reject) => {
                if (typeof lamejs !== 'undefined') {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js';
                script.onload = () => {
                    if (typeof lamejs !== 'undefined') {
                        resolve();
                    } else {
                        reject(new Error('Failed to load lamejs'));
                    }
                };
                script.onerror = () => reject(new Error('Failed to load lamejs script'));
                document.head.appendChild(script);
            });
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const dataLength = buffer.length * blockAlign;
            const headerLength = 44;
            const totalLength = headerLength + dataLength;

            const arrayBuffer = new ArrayBuffer(totalLength);
            const view = new DataView(arrayBuffer);

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, totalLength - 8, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            // Audio data
            const channels = [];
            for (let i = 0; i < numChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, channels[channel][i]));
                    const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
            }

            return arrayBuffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Initialize with default era
        applyPreset(currentEra);
    </script>
</body>
</html>
